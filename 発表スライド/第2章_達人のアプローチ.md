---
marp: true
paginate: true
---

![bg right:55% width:300px](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEh41lUznhkjsR9NwngSotCLl5UWt5aGZ8Vu6MAe81LfDgLqlgDH41jg9N7M5TeD1L-Tx5jc8xKGhZecSQIXevfTJn3YfmepgYKu938UREy6MDFRIjXExN6N7t5gCMjLEhgLyjxr6spdAgI/s450/syugyou3_tatsujin.png)

# 達人プログラマー
## 第2章 達人のアプローチ

---

![bg right:40% width:400px](https://blogger.googleusercontent.com/img/b/R29vZ2xl/AVvXsEgaLQgHVN6FsKkaf_EdVbAgxC-13tnuaXMVcHCjyBVYlFqngZih3vE6SlT3WEL_7YrzYBY9dwhT4eFhqsCa_gUpmkxqgL-cJ_2KG85pxkmZnLCMbySjrDJ3hxcJNLyKqBP8rHr7CLT-Uexn/s400/kadomatsu_gouka.png)

## 本日のテーマ

優れた設計の核心を支える3つの原則

1. **ETC原則**
2. **DRY原則**
3. **直交性**

### なぜこの3つ？

``` 
     ETC（目的）
   ┌────┴────┐
  DRY      直交性
（手段1）  （手段2）
```

---

## 1. ETC: 優れた設計の本質

### ETC = Easier to Change（変更しやすい）

> すべての設計原則は、**変更のしやすさ**に帰結する

### なぜ重要か？

- ソフトウェアの唯一確実なことは「**変わること**」
- 要件は必ず変わる
- 技術も進化する

悩んだら: 「**簡単に変更できそうなコードを書く**」

---

## ETCの実例

### 既存の設計原則もETCで説明できる

| 設計原則 | ETCとの関係 |
|---------|-----------|
| 単一責任原則 | 変更が1箇所で済む |
| 疎結合 | 変更の影響範囲が限定される |
| 依存性の注入 | 実装を切り替えやすい |
| 命名規則 | 変更箇所を見つけやすい |

**ETCは上位概念** - 他の原則の「なぜ」を説明する

---

## 2. DRY原則

### Don't Repeat Yourself

> システム内のあらゆる知識は、単一で、明確な、信頼できる表現でなければならない

### なぜDRYがETCにつながるか？

- 重複がある → 変更時に**複数箇所**を修正
- 修正漏れ → **バグの温床**
- 重複を排除 → 変更は**1箇所だけ**

**DRYはETCを実現する具体的手段**

---

## DRYの3つの重複タイプ

重複は様々な形で現れる:

1. **コードの重複** - 同じロジックが複数箇所に
2. **ドキュメント/コメントの重複** - コードと文書で同じ情報
3. **データの重複** - 同じ情報が複数の場所に格納

それぞれ異なるアプローチが必要

---

## 1. コードの重複

### ❌ 悪い例: ロジックの重複

```java
// 新規ユーザー登録
void registerUser(User user) {
    if (user.age < 18) throw new Exception("18歳未満不可");
    database.save(user);
}

// プレミアム会員登録
void registerPremiumUser(User user) {
    if (user.age < 18) throw new Exception("18歳未満不可");
    user.setPremium(true);
    database.save(user);
}
```

**問題**: 年齢チェックのルールが2箇所に重複

---

## 1. コードの重複（改善）

### ✅ 良い例: バリデーションを共通化

```java
private void validateAge(User user) {
    if (user.age < 18) throw new Exception("18歳未満不可");
}

void registerUser(User user) {
    validateAge(user);
    database.save(user);
}

void registerPremiumUser(User user) {
    validateAge(user);
    user.setPremium(true);
    database.save(user);
}
```

**効果**: 年齢制限を変更したい時、1箇所だけ修正

---

## コードの重複 ≠ 知識の重複

### ⚠️ 注意: すべてのコード重複が悪いわけではない

```java
boolean validateUsername(String name) {
  validateLength(name, 5);
  validateAlphanumeric(name);
}

boolean validatePassword(String pass) {
  validateLength(pass, 5);
  validateAlphanumeric(pass);
}
```

**一見重複に見えるが**: これは「たまたま同じ長さ」というだけ  
→ 将来、ユーザー名は3文字、パスワードは8文字に変更される可能性  
→ **異なる知識を表現しているので、共通化すべきではない**

---

## 2. ドキュメント/コメントの重複

### ❌ 悪い例: コードとコメントで重複

```java
/**
 * ユーザーのパスワードを検証します
 * - 8文字以上
 * - 大文字小文字を含む
 * - 数字を含む
 */
public boolean validatePassword(String password) {
    if (password.length() < 8) return false;
    if (!password.matches(".*[A-Z].*")) return false;
    if (!password.matches(".*[a-z].*")) return false;
    if (!password.matches(".*[0-9].*")) return false;
    return true;
}
```

**問題**: ルールがコメントとコードに重複。コード変更時にコメント更新を忘れる

---

## 2. ドキュメント/コメントの重複（改善）

<style scoped>
pre { font-size: 0.6em; }
</style>

### ✅ 良い例: コードを自己文書化

```java
private static final int MIN_PASSWORD_LENGTH = 8;

private boolean hasUpperCase(String str) {
    return str.matches(".*[A-Z].*");
}

private boolean hasLowerCase(String str) {
    return str.matches(".*[a-z].*");
}

private boolean hasDigit(String str) {
    return str.matches(".*[0-9].*");
}

public boolean validatePassword(String password) {
    return password.length() >= MIN_PASSWORD_LENGTH
        && hasUpperCase(password)
        && hasLowerCase(password)
        && hasDigit(password);
}
```

**効果**: メソッド名で意図を表現。コメント不要で自己文書化

---

## 3. データの重複

### ❌ 悪い例: データ構造の重複

```java
class Order {
    List<OrderItem> items;
    double subtotal;  // 商品の合計
    double tax;       // 消費税
    double total;     // 総額
    // total = subtotal + tax という依存関係
}
```

**問題**: `subtotal`変更時に`tax`と`total`も更新が必要。更新漏れで不整合

---

## 3. データの重複（改善）

<style scoped>
pre { font-size: 0.6em; }
</style>

### ✅ 良い例: 計算可能な値は保持しない

```java
class Order {
    List<OrderItem> items;
    
    // 都度計算する（キャッシュするなら明示的に）
    public double getSubtotal() {
        return items.stream()
            .mapToDouble(item -> item.getPrice())
            .sum();
    }
    
    public double getTax() {
        return getSubtotal() * 0.1;
    }
    
    public double getTotal() {
        return getSubtotal() + getTax();
    }
}
```

**効果**: データの不整合が発生しない。単一の情報源から計算

---

## 重複が生まれる4つの原因

1. **押し付けられた重複** - 環境やフレームワークが重複を強いる
2. **不注意な重複** - 設計ミスで気づかずに重複
3. **我慢できない重複** - 「コピペの方が早い」という焦り
4. **開発者間の重複** - チーム内でコミュニケーション不足

### 対策

- コード生成の活用
- 共通ライブラリの構築
- コードレビューで重複をチェック

---

## 3. 直交性（Orthogonality）

### 独立性を保つことで変更に強くなる

> 2つの要素が直交している = 一方を変更しても他方に影響しない

**直交的**: データベース層変更 → UI層に影響なし  
**非直交的**: データベース変更 → UIコードも修正必要

```
    Y軸     X軸を変更しても
     ↑      Y軸に影響しない
     │
     └────→ X軸
```

### なぜETCにつながるか？

- コンポーネントが独立 → 影響範囲が限定
- 依存関係が少ない → 変更が安全

---

## 直交性の実例

### ❌ 非直交的な設計

```java
class UserManager {
    void saveUser(User user) {
        // データベースに保存
        db.save(user);
        // メール送信
        emailService.send(user.email, "登録完了");
        // ログ記録
        logger.log("User saved: " + user.id);
    }
}
```

**問題**: メール機能を変更すると、ユーザー保存処理に影響
→ 変更しにくい

---

## 直交性の実例

### ✅ 直交的な設計

```java
class UserManager {
    void saveUser(User user) {
        db.save(user);
        eventBus.publish(new UserSavedEvent(user));
    }
}

class EmailNotifier {
    @Subscribe
    void onUserSaved(UserSavedEvent event) {
        emailService.send(event.user.email, "登録完了");
    }
}
```

**効果**: メール機能の変更がユーザー保存処理に影響しない
→ **変更しやすい（ETC）**

---

## 直交性のメリット

### 1. 生産性の向上

✅ **再利用可能** - 独立したコンポーネントは他でも使える  
✅ **並行開発** - チームメンバーが同時に作業可能  
✅ **組み合わせ自由** - 部品を入れ替えても他に影響しない

### 2. リスクの低減

✅ **局所化** - 問題が局所的に収まる  
✅ **テストが容易** - 個別に単体テスト可能  
✅ **安全な修正** - 変更の影響範囲が限定的

**結論**: 直交性は生産性とリスク、両方に効く

---

## 直交性のチェック方法
- ❓ この変更は、無関係な機能に影響しないか？
- ❓ 2つの機能を変更する際、同じファイルを触っていないか？
- ❓ 1つのクラスが複数の責任を持っていないか？

### 直交的なシステムの特徴

✅ **モジュール化** - 各コンポーネントが独立  
✅ **疎結合** - 依存関係が最小限  
✅ **単一責任** - 1つのことだけをする

---

## DRY vs 直交性

### 似ているけど違う

| | DRY | 直交性 |
|---|-----|--------|
| **焦点** | 知識の重複 | コンポーネントの独立性 |
| **問題** | 同じコードが複数箇所 | 変更の影響が広範囲 |
| **解決策** | 共通化・抽出 | 分離・疎結合 |

### 相乗効果

- DRYで重複を排除 **+** 直交性で独立させる  
  = **最高に変更しやすい設計**

---

## 3つの原則の関係

```
        ETC（変更しやすさ）
         ↑      ↑
         |      |
      実現    実現
         |      |
     ┌───┴──┬───┴───┐
     |      |       |
    DRY   直交性   その他
  重複排除  独立性   可逆性
    ↓      ↓       など
  変更箇所  影響範囲
   を1つに  を限定
```

**すべてはETCという目的のための手段**

---

## 実践への第一歩

### 今日から始められること

1. **コードレビュー時の問いかけ**
   - 「これは変更しやすいか？」（ETC）
   - 「重複していないか？」（DRY）
   - 「独立しているか？」（直交性）

2. **リファクタリングの指針**
   - 重複を見つけたら即座に共通化
   - 依存関係が強い部分を分離

3. **新規実装時の意識**
   - 将来の変更を想像して設計する

---

## まとめ

### 優れた設計の核心

**ETC（変更しやすさ）** が最上位の目的

↓ それを実現する2つの強力な手段

- **DRY原則**: 重複を排除して変更箇所を1つに
- **直交性**: 独立させて変更の影響を限定

### 心に刻むべき問い

> 「この変更は、将来の変更を容易にするか？」

**達人への道は、この問いを繰り返すことから始まる**

---

## 参考資料

- **書籍**: The Pragmatic Programmer (20th Anniversary Edition)
- **著者**: David Thomas, Andrew Hunt
- **第2章**: 達人のアプローチ
  - Topic 7: ETC
  - Topic 8: DRY原則
  - Topic 9: 直交性

**コード例**: `DryPrincipleExample.java`
